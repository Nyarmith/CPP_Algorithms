# Smart Pointers

* There are four smart pointers: `auto_ptr` `unique_ptr` `shared_ptr` and `weak_tr`

## 18 - Use std::unique_ptr for exclusive-ownership resource management
- these should probably be the default preferred pointer type
- unique_ptrs are, by default, the same size as raw pointers
- you can make custom deleters (as a sort of surrogate c-tor), but stateful deleters increase the size of the unique_ptr
- converts to a shared pointer for free

## 19 - Use std::shared_ptr for shared ownership resource management
- Reference counting, man
- Not immediately intuitive to visualize "shared ownership" as a concept for runtime objects
- Twice the size of raw_pointers, ref-count memory must be dynamically allocated, increments/decrements of the reference count must be atomic
- Obviously, move-ctoring a std::shared_ptr doesn't have to create a new ref (increment the ref)
- Inc/Dec the ref should be thought of as "expensive" b/c it's atomic
- For std::shared_ptr the deleter is not part of te type, unlike unique_ptr (nicer, I guess, but now it's on the heap)
- Try using std::make_shared and std::make_unique instead of c-tor with a raw pointer (basically avoid having raw ptrs exposed at all)
- If you want to pass `this` as a shared_ptr, you can return `make_shared_from_this` to not have two separate ref-count lads working at turbo-charge (and leaving memory dangling)
  - furnishes method `shared_from_this()`
  - crtp!
- shared_ptrs cant work with arrays!
  - Made to point at a single object I guess


## 20 - Use std::weak_ptr for std::shared_ptr-like pointers that can dangle
- Weak ptr basically specializes by being a Maybe monad, in that it can handle the ptr-less states with the same interface
- The weak ptr can get a lock and return a shared pointer!
- These are basically a patch to shared_pointers
- Uses: caching, sub/pub, avoiding shared_ptr cycles

## 21 - Prefer std::make_unique and std::make_shared to direct use of new

